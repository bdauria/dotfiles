'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._flowSemverForRootPath = exports.flowBinForPath = undefined;

var _asyncToGenerator = require('async-to-generator');

var _asyncToGenerator2 = _interopRequireDefault(_asyncToGenerator);

let flowBinForPath = exports.flowBinForPath = (() => {
  var _ref3 = (0, _asyncToGenerator2.default)(function* (rootPath, {
    tryFlowBin = false,
    autoDownloadFlow = true,
    semverDownloader = _githubSemverDownloader.downloadSemverFromGitHub,
    reporter = (0, _log4js.getLogger)('flow-versions')
  }) {
    // get the version (or range) of flow we'll need for this path
    const semversion = yield _flowSemverForRootPath(rootPath, reporter);
    if (semversion == null) {
      return null;
    }
    reporter.info(`Looking for a version of flow matching ${semversion}...`);

    if (tryFlowBin) {
      let versionInfo = yield (0, _utils.versionInfoForPath)(rootPath, _nuclideUri2.default.join(rootPath, 'node_modules', '.bin', _constants.BIN_NAME));
      if (versionInfo == null && process.platform === 'win32') {
        // In newer flow-bin versions, flow.cmd is used instead of flow.exe.
        versionInfo = yield (0, _utils.versionInfoForPath)(rootPath, _nuclideUri2.default.join(rootPath, 'node_modules', '.bin', 'flow.cmd'));
      }

      reporter.info('version info', versionInfo);
      if (versionInfo) {
        if (_semver2.default.satisfies(versionInfo.flowVersion, semversion)) {
          reporter.info('Using the flow bin in node_modules');
          return versionInfo;
        } else {
          reporter.error('The version of flow-bin (declared in package.json) is incompatible ' + "with the range stated in the project's .flowconfig, and will not run.");
          return null;
        }
      } else {
        reporter.info('Unable to locate flow-bin in node_modules');
      }
    }

    // see if the system flow satisfies before downloading one
    const systemFlowPath = yield (0, _which2.default)('flow');
    if (systemFlowPath) {
      const versionInfo = yield (0, _utils.versionInfoForPath)(rootPath, systemFlowPath);
      if (versionInfo) {
        if (_semver2.default.satisfies(versionInfo.flowVersion, semversion)) {
          reporter.info(`Using the system flow at ${systemFlowPath}.`);
          return versionInfo;
        } else {
          reporter.info('System flow found, but does not satisfy the current project.');
        }
      } else {
        reporter.info('System flow not found.');
      }
    }

    if (autoDownloadFlow) {
      reporter.info('Checking the disk cache for a local copy of flow...');
      const fromDisk = yield getFromDiskCache(semversion);
      if (fromDisk) {
        reporter.info(`Found flow version ${fromDisk.flowVersion} on disk.`);
        yield _fsPromise2.default.chmod(fromDisk.pathToFlow, '0755');
        return fromDisk;
      }

      reporter.info('No suitable flow found on disk');
      const dest = yield semverDownloader(semversion, _constants.BINS_DIR, reporter);
      if (dest) {
        yield _fsPromise2.default.chmod(dest.pathToFlow, '0755');
        return dest;
      }
    }

    reporter.error('Unable to find a suitable version of flow.');
  });

  return function flowBinForPath(_x, _x2) {
    return _ref3.apply(this, arguments);
  };
})();

// exported to test


let _flowSemverForRootPath = exports._flowSemverForRootPath = (() => {
  var _ref4 = (0, _asyncToGenerator2.default)(function* (rootPath, reporter) {
    var _ref, _ref2;

    const configDir = yield flowConfigCache.getConfigDir(rootPath);
    reporter.info('Determining the version of flow for your project...');
    if (!configDir) {
      reporter.error('No valid .flowconfig was found. Use `flow init` in the root of your project to create one.');
      return null;
    }
    const configPath = _path2.default.join(configDir, '.flowconfig');

    var _ref5 = yield (0, _readPkgUp2.default)({ cwd: rootPath });

    const pkg = _ref5.pkg;


    let packageFlowVersion;
    const depRange = (_ref = pkg) != null ? (_ref = _ref.dependencies) != null ? _ref['flow-bin'] : _ref : _ref;
    const devDepRange = (_ref2 = pkg) != null ? (_ref2 = _ref2.devDependencies) != null ? _ref2['flow-bin'] : _ref2 : _ref2;
    if (depRange && _semver2.default.validRange(depRange)) {
      packageFlowVersion = depRange;
    } else if (devDepRange && _semver2.default.validRange(devDepRange)) {
      packageFlowVersion = devDepRange;
    }
    if (packageFlowVersion) {
      reporter.info(`Found flow version requirement ${packageFlowVersion} in your package.json`);
    }

    let configFlowVersion;
    if (configDir) {
      try {
        const configFileStr = yield _fsPromise2.default.readFile(configPath, 'utf-8');
        const flowConfig = _ini2.default.parse(configFileStr);
        if (typeof flowConfig.version === 'object') {
          const rawConfigVersion = Object.keys(flowConfig.version)[0];
          configFlowVersion = _semver2.default.validRange(rawConfigVersion) ? rawConfigVersion : null;
        }
      } catch (e) {
        reporter.error('Root dir contains missing or invalid flowconfig');
        return null;
      }
    }

    if (configFlowVersion) {
      reporter.info(`Found flow version requirement ${configFlowVersion} in your .flowconfig`);
    }

    if (!configFlowVersion && !packageFlowVersion) {
      reporter.warn('No valid version of flow specified in .flowconfig or flow-bin ' + 'dependency of package.json. It is strongly recommended you specify a ' + 'version in your .flowconfig.');
    }

    return configFlowVersion || packageFlowVersion || '*';
  });

  return function _flowSemverForRootPath(_x3, _x4) {
    return _ref4.apply(this, arguments);
  };
})();

let getFromDiskCache = (() => {
  var _ref6 = (0, _asyncToGenerator2.default)(function* (semversion) {
    let diskVersions;
    try {
      diskVersions = (yield _fsPromise2.default.readdir(_constants.BINS_DIR)).filter(_semver2.default.valid);
    } catch (e) {
      return null;
    }

    const foundVersion = diskVersions.sort(function (a, b) {
      return -1 * _semver2.default.compare(a, b);
    }).find(function (v) {
      return _semver2.default.satisfies(v, semversion);
    });

    if (!foundVersion) {
      return null;
    }

    const foundPath = _path2.default.join(_constants.BINS_DIR, foundVersion, _constants.BIN_NAME);
    try {
      if (yield _fsPromise2.default.stat(foundPath)) {
        return {
          pathToFlow: foundPath,
          flowVersion: foundVersion
        };
      }
    } catch (e) {
      return null;
    }

    return null;
  });

  return function getFromDiskCache(_x5) {
    return _ref6.apply(this, arguments);
  };
})();

var _ConfigCache = require('nuclide-commons/ConfigCache');

var _nuclideUri = require('nuclide-commons/nuclideUri');

var _nuclideUri2 = _interopRequireDefault(_nuclideUri);

var _ini = require('ini');

var _ini2 = _interopRequireDefault(_ini);

var _readPkgUp = require('read-pkg-up');

var _readPkgUp2 = _interopRequireDefault(_readPkgUp);

var _fsPromise = require('nuclide-commons/fsPromise');

var _fsPromise2 = _interopRequireDefault(_fsPromise);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var _which = require('nuclide-commons/which');

var _which2 = _interopRequireDefault(_which);

var _constants = require('./constants');

var _githubSemverDownloader = require('./githubSemverDownloader');

var _utils = require('./utils');

var _log4js = require('log4js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const flowConfigCache = new _ConfigCache.ConfigCache(['.flowconfig']); /**
                                                                        * Copyright (c) 2017-present, Facebook, Inc.
                                                                        * All rights reserved.
                                                                        *
                                                                        * This source code is licensed under the BSD-style license found in the
                                                                        * LICENSE file in the root directory of this source tree. An additional grant
                                                                        * of patent rights can be found in the PATENTS file in the same directory.
                                                                        *
                                                                        * 
                                                                        * @format
                                                                        */
//# sourceMappingURL=flowBinForRoot.js.map