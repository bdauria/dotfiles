'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = function (DOMNode) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _deepmerge = (0, _deepmerge3.default)(defaultOptions, options);

  var id = _deepmerge.id;
  var style = _deepmerge.style;
  var size = _deepmerge.size;
  var aspectRatio = _deepmerge.aspectRatio;
  var initialZoom = _deepmerge.initialZoom;
  var margin = _deepmerge.margin;
  var isSorted = _deepmerge.isSorted;
  var widthBetweenNodesCoeff = _deepmerge.widthBetweenNodesCoeff;
  var heightBetweenNodesCoeff = _deepmerge.heightBetweenNodesCoeff;
  var transitionDuration = _deepmerge.transitionDuration;
  var state = _deepmerge.state;
  var rootKeyName = _deepmerge.rootKeyName;
  var pushMethod = _deepmerge.pushMethod;
  var tree = _deepmerge.tree;
  var tooltipOptions = _deepmerge.tooltipOptions;
  var onClickText = _deepmerge.onClickText;


  var width = size - margin.left - margin.right;
  var height = size * aspectRatio - margin.top - margin.bottom;
  var fullWidth = size;
  var fullHeight = size * aspectRatio;

  var attr = {
    id: id,
    preserveAspectRatio: 'xMinYMin slice'
  };

  if (!style.width) {
    attr.width = fullWidth;
  }

  if (!style.width || !style.height) {
    attr.viewBox = '0 0 ' + fullWidth + ' ' + fullHeight;
  }

  var root = _d4.default.select(DOMNode);
  var zoom = _d4.default.behavior.zoom().scaleExtent([0.1, 3]).scale(initialZoom);
  var vis = root.append('svg').attr(attr).style(_extends({ cursor: '-webkit-grab' }, style)).call(zoom.on('zoom', function () {
    var _d3$event = _d4.default.event;
    var translate = _d3$event.translate;
    var scale = _d3$event.scale;

    vis.attr('transform', 'translate(' + translate + ')scale(' + scale + ')');
  })).append('g').attr({
    transform: 'translate(' + (margin.left + style.node.radius) + ', ' + margin.top + ') scale(' + initialZoom + ')'
  });

  var layout = _d4.default.layout.tree().size([width, height]);
  var data = void 0;

  if (isSorted) {
    layout.sort(function (a, b) {
      return b.name.toLowerCase() < a.name.toLowerCase() ? 1 : -1;
    });
  }

  return function renderChart() {
    var nextState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : tree || state;

    data = !tree ? (0, _map2tree2.default)(nextState, { key: rootKeyName, pushMethod: pushMethod }) : nextState;

    if ((0, _ramda.isEmpty)(data) || !data.name) {
      data = { name: 'error', message: 'Please provide a state map or a tree structure' };
    }

    var nodeIndex = 0;
    var maxLabelLength = 0;

    (0, _utils.visit)(data, function (node) {
      return maxLabelLength = Math.max(node.name.length, maxLabelLength);
    }, function (node) {
      return node.children && node.children.length > 0 ? node.children : null;
    });

    data.x0 = height / 2;
    data.y0 = 0;
    /*eslint-disable*/
    update(data);
    /*eslint-enable*/

    function update(source) {
      // path generator for links
      var diagonal = _d4.default.svg.diagonal().projection(function (d) {
        return [d.y, d.x];
      });
      // set tree dimensions and spacing between branches and nodes
      var maxNodeCountByLevel = Math.max.apply(Math, (0, _utils.getNodeGroupByDepthCount)(data));

      layout = layout.size([maxNodeCountByLevel * 25 * heightBetweenNodesCoeff, width]);

      var nodes = layout.nodes(data);
      var links = layout.links(nodes);

      nodes.forEach(function (node) {
        return node.y = node.depth * (maxLabelLength * 7 * widthBetweenNodesCoeff);
      });

      // process the node selection
      var node = vis.selectAll('g.node').property('__oldData__', function (d) {
        return d;
      }).data(nodes, function (d) {
        return d.id || (d.id = ++nodeIndex);
      });

      var nodeEnter = node.enter().append('g').attr({
        'class': 'node',
        transform: function transform(d) {
          return 'translate(' + source.y0 + ',' + source.x0 + ')';
        }
      }).style({
        fill: style.text.colors.default,
        cursor: 'pointer'
      }).on({
        mouseover: function mouseover(d, i) {
          _d4.default.select(this).style({
            fill: style.text.colors.hover
          });
        },
        mouseout: function mouseout(d, i) {
          _d4.default.select(this).style({
            fill: style.text.colors.default
          });
        }
      });

      if (!tooltipOptions.disabled) {
        nodeEnter.call((0, _d3tooltip2.default)(_d4.default, 'tooltip', _extends({}, tooltipOptions, { root: root })).text(function (d, i) {
          return (0, _utils.getTooltipString)(d, i, tooltipOptions);
        }).style(tooltipOptions.style));
      }

      nodeEnter.append('circle').attr({
        'class': 'nodeCircle'
      }).on({
        click: function click(clickedNode) {
          if (_d4.default.event.defaultPrevented) return;
          update((0, _utils.toggleChildren)(clickedNode));
        }
      });

      nodeEnter.append('text').attr({
        'class': 'nodeText',
        dy: '.35em'
      }).style({
        'fill-opacity': 0
      }).text(function (d) {
        return d.name;
      }).on({
        click: onClickText
      });

      // update the text to reflect whether node has children or not
      node.select('text').attr({
        x: function x(d) {
          return d.children || d._children ? -(style.node.radius + 10) : style.node.radius + 10;
        },
        'text-anchor': function textAnchor(d) {
          return d.children || d._children ? 'end' : 'start';
        }
      }).text(function (d) {
        return d.name;
      });

      // change the circle fill depending on whether it has children and is collapsed
      node.select('circle.nodeCircle').attr({
        r: style.node.radius
      }).style({
        stroke: 'black',
        'stroke-width': '1.5px',
        fill: function fill(d) {
          return d._children ? style.node.colors.collapsed : d.children ? style.node.colors.parent : style.node.colors.default;
        }
      });

      // transition nodes to their new position
      var nodeUpdate = node.transition().duration(transitionDuration).attr({
        transform: function transform(d) {
          return 'translate(' + d.y + ',' + d.x + ')';
        }
      });

      // fade the text in
      nodeUpdate.select('text').style('fill-opacity', 1);

      // restore the circle
      nodeUpdate.select('circle').attr('r', 7);

      // blink updated nodes
      nodeUpdate.filter(function flick(d) {
        // test whether the relevant properties of d match
        // the equivalent property of the oldData
        // also test whether the old data exists,
        // to catch the entering elements!
        return !this.__oldData__ || d.value !== this.__oldData__.value;
      }).style('fill-opacity', '0.3').transition().duration(100).style('fill-opacity', '1');

      // transition exiting nodes to the parent's new position
      var nodeExit = node.exit().transition().duration(transitionDuration).attr({
        transform: function transform(d) {
          return 'translate(' + source.y + ',' + source.x + ')';
        }
      }).remove();

      nodeExit.select('circle').attr('r', 0);

      nodeExit.select('text').style('fill-opacity', 0);

      // update the links
      var link = vis.selectAll('path.link').data(links, function (d) {
        return d.target.id;
      });

      // enter any new links at the parent's previous position
      link.enter().insert('path', 'g').attr({
        'class': 'link',
        d: function d(_d) {
          var o = {
            x: source.x0,
            y: source.y0
          };
          return diagonal({
            source: o,
            target: o
          });
        }
      }).style(style.link);

      // transition links to their new position
      link.transition().duration(transitionDuration).attr({
        d: diagonal
      });

      // transition exiting nodes to the parent's new position
      link.exit().transition().duration(transitionDuration).attr({
        d: function d(_d2) {
          var o = {
            x: source.x,
            y: source.y
          };
          return diagonal({
            source: o,
            target: o
          });
        }
      }).remove();

      // delete the old data once it's no longer needed
      node.property('__oldData__', null);

      // stash the old positions for transition
      nodes.forEach(function (d) {
        d.x0 = d.x;
        d.y0 = d.y;
      });
    }
  };
};

var _d3 = require('d3');

var _d4 = _interopRequireDefault(_d3);

var _ramda = require('ramda');

var _map2tree = require('map2tree');

var _map2tree2 = _interopRequireDefault(_map2tree);

var _deepmerge2 = require('deepmerge');

var _deepmerge3 = _interopRequireDefault(_deepmerge2);

var _utils = require('./utils');

var _d3tooltip = require('d3tooltip');

var _d3tooltip2 = _interopRequireDefault(_d3tooltip);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultOptions = {
  state: undefined,
  rootKeyName: 'state',
  pushMethod: 'push',
  tree: undefined,
  id: 'd3svg',
  style: {
    node: {
      colors: {
        'default': '#ccc',
        collapsed: 'lightsteelblue',
        parent: 'white'
      },
      radius: 5
    },
    text: {
      colors: {
        'default': 'black',
        hover: 'skyblue'
      }
    },
    link: {
      stroke: '#000',
      fill: 'none'
    }
  },
  size: 500,
  aspectRatio: 1.0,
  initialZoom: 1,
  margin: {
    top: 10,
    right: 10,
    bottom: 10,
    left: 50
  },
  isSorted: false,
  heightBetweenNodesCoeff: 2,
  widthBetweenNodesCoeff: 1,
  transitionDuration: 750,
  onClickText: function onClickText() {},
  tooltipOptions: {
    disabled: false,
    left: undefined,
    right: undefined,
    offset: {
      left: 0,
      top: 0
    },
    style: undefined
  }
};