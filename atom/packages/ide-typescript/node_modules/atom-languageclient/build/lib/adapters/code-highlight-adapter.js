"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const convert_1 = require("../convert");
class CodeHighlightAdapter {
    // Returns a {Boolean} indicating this adapter can adapt the server based on the
    // given serverCapabilities.
    static canAdapt(serverCapabilities) {
        return serverCapabilities.documentHighlightProvider === true;
    }
    // Public: Creates highlight markers for a given editor position.
    // Throws an error if documentHighlightProvider is not a registered capability.
    //
    // * `connection` A {LanguageClientConnection} to the language server that provides highlights.
    // * `serverCapabilities` The {ServerCapabilities} of the language server that will be used.
    // * `editor` The Atom {TextEditor} containing the text to be highlighted.
    // * `position` The Atom {Point} to fetch highlights for.
    //
    // Returns a {Promise} of an {Array} of {Range}s to be turned into highlights.
    static highlight(connection, serverCapabilities, editor, position) {
        return __awaiter(this, void 0, void 0, function* () {
            assert(serverCapabilities.documentHighlightProvider, 'Must have the documentHighlight capability');
            const highlights = yield connection.documentHighlight(convert_1.default.editorToTextDocumentPositionParams(editor, position));
            return highlights.map((highlight) => {
                return convert_1.default.lsRangeToAtomRange(highlight.range);
            });
        });
    }
}
exports.default = CodeHighlightAdapter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29kZS1oaWdobGlnaHQtYWRhcHRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL2xpYi9hZGFwdGVycy9jb2RlLWhpZ2hsaWdodC1hZGFwdGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxpQ0FBa0M7QUFHbEMsd0NBQWlDO0FBRWpDO0lBQ0UsZ0ZBQWdGO0lBQ2hGLDRCQUE0QjtJQUNyQixNQUFNLENBQUMsUUFBUSxDQUFDLGtCQUFzQztRQUMzRCxNQUFNLENBQUMsa0JBQWtCLENBQUMseUJBQXlCLEtBQUssSUFBSSxDQUFDO0lBQy9ELENBQUM7SUFFRCxpRUFBaUU7SUFDakUsK0VBQStFO0lBQy9FLEVBQUU7SUFDRiwrRkFBK0Y7SUFDL0YsNEZBQTRGO0lBQzVGLDBFQUEwRTtJQUMxRSx5REFBeUQ7SUFDekQsRUFBRTtJQUNGLDhFQUE4RTtJQUN2RSxNQUFNLENBQU8sU0FBUyxDQUMzQixVQUFvQyxFQUNwQyxrQkFBc0MsRUFDdEMsTUFBa0IsRUFDbEIsUUFBZTs7WUFFZixNQUFNLENBQUMsa0JBQWtCLENBQUMseUJBQXlCLEVBQUUsNENBQTRDLENBQUMsQ0FBQztZQUNuRyxNQUFNLFVBQVUsR0FBRyxNQUFNLFVBQVUsQ0FBQyxpQkFBaUIsQ0FBQyxpQkFBTyxDQUFDLGtDQUFrQyxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDO1lBQ3BILE1BQU0sQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUU7Z0JBQ2xDLE1BQU0sQ0FBQyxpQkFBTyxDQUFDLGtCQUFrQixDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUNyRCxDQUFDLENBQUMsQ0FBQztRQUNMLENBQUM7S0FBQTtDQUNGO0FBNUJELHVDQTRCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKTtcclxuaW1wb3J0IHsgUG9pbnQsIFRleHRFZGl0b3IsIFJhbmdlIH0gZnJvbSAnYXRvbSc7XHJcbmltcG9ydCB7IExhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbiwgU2VydmVyQ2FwYWJpbGl0aWVzIH0gZnJvbSAnLi4vbGFuZ3VhZ2VjbGllbnQnO1xyXG5pbXBvcnQgQ29udmVydCBmcm9tICcuLi9jb252ZXJ0JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvZGVIaWdobGlnaHRBZGFwdGVyIHtcclxuICAvLyBSZXR1cm5zIGEge0Jvb2xlYW59IGluZGljYXRpbmcgdGhpcyBhZGFwdGVyIGNhbiBhZGFwdCB0aGUgc2VydmVyIGJhc2VkIG9uIHRoZVxyXG4gIC8vIGdpdmVuIHNlcnZlckNhcGFiaWxpdGllcy5cclxuICBwdWJsaWMgc3RhdGljIGNhbkFkYXB0KHNlcnZlckNhcGFiaWxpdGllczogU2VydmVyQ2FwYWJpbGl0aWVzKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gc2VydmVyQ2FwYWJpbGl0aWVzLmRvY3VtZW50SGlnaGxpZ2h0UHJvdmlkZXIgPT09IHRydWU7XHJcbiAgfVxyXG5cclxuICAvLyBQdWJsaWM6IENyZWF0ZXMgaGlnaGxpZ2h0IG1hcmtlcnMgZm9yIGEgZ2l2ZW4gZWRpdG9yIHBvc2l0aW9uLlxyXG4gIC8vIFRocm93cyBhbiBlcnJvciBpZiBkb2N1bWVudEhpZ2hsaWdodFByb3ZpZGVyIGlzIG5vdCBhIHJlZ2lzdGVyZWQgY2FwYWJpbGl0eS5cclxuICAvL1xyXG4gIC8vICogYGNvbm5lY3Rpb25gIEEge0xhbmd1YWdlQ2xpZW50Q29ubmVjdGlvbn0gdG8gdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHByb3ZpZGVzIGhpZ2hsaWdodHMuXHJcbiAgLy8gKiBgc2VydmVyQ2FwYWJpbGl0aWVzYCBUaGUge1NlcnZlckNhcGFiaWxpdGllc30gb2YgdGhlIGxhbmd1YWdlIHNlcnZlciB0aGF0IHdpbGwgYmUgdXNlZC5cclxuICAvLyAqIGBlZGl0b3JgIFRoZSBBdG9tIHtUZXh0RWRpdG9yfSBjb250YWluaW5nIHRoZSB0ZXh0IHRvIGJlIGhpZ2hsaWdodGVkLlxyXG4gIC8vICogYHBvc2l0aW9uYCBUaGUgQXRvbSB7UG9pbnR9IHRvIGZldGNoIGhpZ2hsaWdodHMgZm9yLlxyXG4gIC8vXHJcbiAgLy8gUmV0dXJucyBhIHtQcm9taXNlfSBvZiBhbiB7QXJyYXl9IG9mIHtSYW5nZX1zIHRvIGJlIHR1cm5lZCBpbnRvIGhpZ2hsaWdodHMuXHJcbiAgcHVibGljIHN0YXRpYyBhc3luYyBoaWdobGlnaHQoXHJcbiAgICBjb25uZWN0aW9uOiBMYW5ndWFnZUNsaWVudENvbm5lY3Rpb24sXHJcbiAgICBzZXJ2ZXJDYXBhYmlsaXRpZXM6IFNlcnZlckNhcGFiaWxpdGllcyxcclxuICAgIGVkaXRvcjogVGV4dEVkaXRvcixcclxuICAgIHBvc2l0aW9uOiBQb2ludCxcclxuICApOiBQcm9taXNlPFJhbmdlW10gfCBudWxsPiB7XHJcbiAgICBhc3NlcnQoc2VydmVyQ2FwYWJpbGl0aWVzLmRvY3VtZW50SGlnaGxpZ2h0UHJvdmlkZXIsICdNdXN0IGhhdmUgdGhlIGRvY3VtZW50SGlnaGxpZ2h0IGNhcGFiaWxpdHknKTtcclxuICAgIGNvbnN0IGhpZ2hsaWdodHMgPSBhd2FpdCBjb25uZWN0aW9uLmRvY3VtZW50SGlnaGxpZ2h0KENvbnZlcnQuZWRpdG9yVG9UZXh0RG9jdW1lbnRQb3NpdGlvblBhcmFtcyhlZGl0b3IsIHBvc2l0aW9uKSk7XHJcbiAgICByZXR1cm4gaGlnaGxpZ2h0cy5tYXAoKGhpZ2hsaWdodCkgPT4ge1xyXG4gICAgICByZXR1cm4gQ29udmVydC5sc1JhbmdlVG9BdG9tUmFuZ2UoaGlnaGxpZ2h0LnJhbmdlKTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG4iXX0=