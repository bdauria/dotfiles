"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
// Public: Download a file and store it on a file system using streaming with appropriate progress callback.
//
// * `sourceUrl`        Url to download from.
// * `targetFile`       File path to save to.
// * `progressCallback` Callback function that will be given a {ByteProgressCallback} object containing
//                      both bytesDone and percent.
// * `length`           Optional file length in bytes for cases where the server will not supply the
//                      Content-Length header but the value is known in advance. Without either the
//                      percentage on the callback can not be determined.
//
// Returns a {Promise} that will accept when complete.
exports.default = (function downloadFile(sourceUrl, targetFile, progressCallback, length) {
    return __awaiter(this, void 0, void 0, function* () {
        const request = new Request(sourceUrl, {
            headers: new Headers({ 'Content-Type': 'application/octet-stream' }),
        });
        const response = yield fetch(request);
        if (!response.ok) {
            throw Error(`Unable to download, server returned ${response.status} ${response.statusText}`);
        }
        const body = response.body;
        if (body == null) {
            throw Error('No response body');
        }
        const finalLength = length || parseInt(response.headers.get('Content-Length') || '0', 10);
        const reader = body.getReader();
        const writer = fs.createWriteStream(targetFile);
        yield streamWithProgress(finalLength, reader, writer, progressCallback);
        writer.end();
    });
});
// Stream from a {ReadableStreamReader} to a {WriteStream} with progress callback.
//
// * `length`           File length in bytes.
// * `reader`           {ReadableStreamReader} to read from.
// * `targwriteretFile` {WriteStream} to write to.
// * `progressCallback` Callback function that will be given a {ByteProgressCallback} object containing
//                      both bytesDone and percent.
//
// Returns a {Promise} that will accept when complete.
function streamWithProgress(length, reader, writer, progressCallback) {
    return __awaiter(this, void 0, void 0, function* () {
        let bytesDone = 0;
        while (true) {
            const result = yield reader.read();
            if (result.done) {
                if (progressCallback != null) {
                    progressCallback(length, 100);
                }
                return;
            }
            const chunk = result.value;
            if (chunk == null) {
                throw Error('Empty chunk received during download');
            }
            else {
                writer.write(Buffer.from(chunk));
                if (progressCallback != null) {
                    bytesDone += chunk.byteLength;
                    const percent = length === 0 ? undefined : Math.floor(bytesDone / length * 100);
                    progressCallback(bytesDone, percent);
                }
            }
        }
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG93bmxvYWQtZmlsZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL2xpYi9kb3dubG9hZC1maWxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSx5QkFBeUI7QUFFekIsNEdBQTRHO0FBQzVHLEVBQUU7QUFDRiw2Q0FBNkM7QUFDN0MsNkNBQTZDO0FBQzdDLHVHQUF1RztBQUN2RyxtREFBbUQ7QUFDbkQsb0dBQW9HO0FBQ3BHLG1HQUFtRztBQUNuRyx5RUFBeUU7QUFDekUsRUFBRTtBQUNGLHNEQUFzRDtBQUN0RCxrQkFBZSxDQUFDLHNCQUNkLFNBQWlCLEVBQ2pCLFVBQWtCLEVBQ2xCLGdCQUF1QyxFQUN2QyxNQUFlOztRQUVmLE1BQU0sT0FBTyxHQUFHLElBQUksT0FBTyxDQUFDLFNBQVMsRUFBRTtZQUNyQyxPQUFPLEVBQUUsSUFBSSxPQUFPLENBQUMsRUFBQyxjQUFjLEVBQUUsMEJBQTBCLEVBQUMsQ0FBQztTQUNuRSxDQUFDLENBQUM7UUFFSCxNQUFNLFFBQVEsR0FBRyxNQUFNLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN0QyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ2pCLE1BQU0sS0FBSyxDQUFDLHVDQUF1QyxRQUFRLENBQUMsTUFBTSxJQUFJLFFBQVEsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDO1FBQy9GLENBQUM7UUFFRCxNQUFNLElBQUksR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDO1FBQzNCLEVBQUUsQ0FBQyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQ2pCLE1BQU0sS0FBSyxDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFDbEMsQ0FBQztRQUVELE1BQU0sV0FBVyxHQUFHLE1BQU0sSUFBSSxRQUFRLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxHQUFHLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDMUYsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ2hDLE1BQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUVoRCxNQUFNLGtCQUFrQixDQUFDLFdBQVcsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLGdCQUFnQixDQUFDLENBQUM7UUFDeEUsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ2YsQ0FBQztDQUFBLENBQUMsQ0FBQztBQUVILGtGQUFrRjtBQUNsRixFQUFFO0FBQ0YsNkNBQTZDO0FBQzdDLDREQUE0RDtBQUM1RCxrREFBa0Q7QUFDbEQsdUdBQXVHO0FBQ3ZHLG1EQUFtRDtBQUNuRCxFQUFFO0FBQ0Ysc0RBQXNEO0FBQ3RELDRCQUNFLE1BQWMsRUFDZCxNQUE0QixFQUM1QixNQUFzQixFQUN0QixnQkFBdUM7O1FBRXZDLElBQUksU0FBUyxHQUFHLENBQUMsQ0FBQztRQUVsQixPQUFPLElBQUksRUFBRSxDQUFDO1lBQ1osTUFBTSxNQUFNLEdBQUcsTUFBTSxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDbkMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQ2hCLEVBQUUsQ0FBQyxDQUFDLGdCQUFnQixJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7b0JBQzdCLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztnQkFDaEMsQ0FBQztnQkFDRCxNQUFNLENBQUM7WUFDVCxDQUFDO1lBRUQsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQztZQUMzQixFQUFFLENBQUMsQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztnQkFDbEIsTUFBTSxLQUFLLENBQUMsc0NBQXNDLENBQUMsQ0FBQztZQUN0RCxDQUFDO1lBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ04sTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Z0JBQ2pDLEVBQUUsQ0FBQyxDQUFDLGdCQUFnQixJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7b0JBQzdCLFNBQVMsSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFDO29CQUM5QixNQUFNLE9BQU8sR0FBdUIsTUFBTSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUM7b0JBQ3BHLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQztnQkFDdkMsQ0FBQztZQUNILENBQUM7UUFDSCxDQUFDO0lBQ0gsQ0FBQztDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xyXG5cclxuLy8gUHVibGljOiBEb3dubG9hZCBhIGZpbGUgYW5kIHN0b3JlIGl0IG9uIGEgZmlsZSBzeXN0ZW0gdXNpbmcgc3RyZWFtaW5nIHdpdGggYXBwcm9wcmlhdGUgcHJvZ3Jlc3MgY2FsbGJhY2suXHJcbi8vXHJcbi8vICogYHNvdXJjZVVybGAgICAgICAgIFVybCB0byBkb3dubG9hZCBmcm9tLlxyXG4vLyAqIGB0YXJnZXRGaWxlYCAgICAgICBGaWxlIHBhdGggdG8gc2F2ZSB0by5cclxuLy8gKiBgcHJvZ3Jlc3NDYWxsYmFja2AgQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGdpdmVuIGEge0J5dGVQcm9ncmVzc0NhbGxiYWNrfSBvYmplY3QgY29udGFpbmluZ1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICBib3RoIGJ5dGVzRG9uZSBhbmQgcGVyY2VudC5cclxuLy8gKiBgbGVuZ3RoYCAgICAgICAgICAgT3B0aW9uYWwgZmlsZSBsZW5ndGggaW4gYnl0ZXMgZm9yIGNhc2VzIHdoZXJlIHRoZSBzZXJ2ZXIgd2lsbCBub3Qgc3VwcGx5IHRoZVxyXG4vLyAgICAgICAgICAgICAgICAgICAgICBDb250ZW50LUxlbmd0aCBoZWFkZXIgYnV0IHRoZSB2YWx1ZSBpcyBrbm93biBpbiBhZHZhbmNlLiBXaXRob3V0IGVpdGhlciB0aGVcclxuLy8gICAgICAgICAgICAgICAgICAgICAgcGVyY2VudGFnZSBvbiB0aGUgY2FsbGJhY2sgY2FuIG5vdCBiZSBkZXRlcm1pbmVkLlxyXG4vL1xyXG4vLyBSZXR1cm5zIGEge1Byb21pc2V9IHRoYXQgd2lsbCBhY2NlcHQgd2hlbiBjb21wbGV0ZS5cclxuZXhwb3J0IGRlZmF1bHQgKGFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkRmlsZShcclxuICBzb3VyY2VVcmw6IHN0cmluZyxcclxuICB0YXJnZXRGaWxlOiBzdHJpbmcsXHJcbiAgcHJvZ3Jlc3NDYWxsYmFjaz86IEJ5dGVQcm9ncmVzc0NhbGxiYWNrLFxyXG4gIGxlbmd0aD86IG51bWJlcixcclxuKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgY29uc3QgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHNvdXJjZVVybCwge1xyXG4gICAgaGVhZGVyczogbmV3IEhlYWRlcnMoeydDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJ30pLFxyXG4gIH0pO1xyXG5cclxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QpO1xyXG4gIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gZG93bmxvYWQsIHNlcnZlciByZXR1cm5lZCAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgYm9keSA9IHJlc3BvbnNlLmJvZHk7XHJcbiAgaWYgKGJvZHkgPT0gbnVsbCkge1xyXG4gICAgdGhyb3cgRXJyb3IoJ05vIHJlc3BvbnNlIGJvZHknKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IGZpbmFsTGVuZ3RoID0gbGVuZ3RoIHx8IHBhcnNlSW50KHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdDb250ZW50LUxlbmd0aCcpIHx8ICcwJywgMTApO1xyXG4gIGNvbnN0IHJlYWRlciA9IGJvZHkuZ2V0UmVhZGVyKCk7XHJcbiAgY29uc3Qgd3JpdGVyID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0odGFyZ2V0RmlsZSk7XHJcblxyXG4gIGF3YWl0IHN0cmVhbVdpdGhQcm9ncmVzcyhmaW5hbExlbmd0aCwgcmVhZGVyLCB3cml0ZXIsIHByb2dyZXNzQ2FsbGJhY2spO1xyXG4gIHdyaXRlci5lbmQoKTtcclxufSk7XHJcblxyXG4vLyBTdHJlYW0gZnJvbSBhIHtSZWFkYWJsZVN0cmVhbVJlYWRlcn0gdG8gYSB7V3JpdGVTdHJlYW19IHdpdGggcHJvZ3Jlc3MgY2FsbGJhY2suXHJcbi8vXHJcbi8vICogYGxlbmd0aGAgICAgICAgICAgIEZpbGUgbGVuZ3RoIGluIGJ5dGVzLlxyXG4vLyAqIGByZWFkZXJgICAgICAgICAgICB7UmVhZGFibGVTdHJlYW1SZWFkZXJ9IHRvIHJlYWQgZnJvbS5cclxuLy8gKiBgdGFyZ3dyaXRlcmV0RmlsZWAge1dyaXRlU3RyZWFtfSB0byB3cml0ZSB0by5cclxuLy8gKiBgcHJvZ3Jlc3NDYWxsYmFja2AgQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGdpdmVuIGEge0J5dGVQcm9ncmVzc0NhbGxiYWNrfSBvYmplY3QgY29udGFpbmluZ1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICBib3RoIGJ5dGVzRG9uZSBhbmQgcGVyY2VudC5cclxuLy9cclxuLy8gUmV0dXJucyBhIHtQcm9taXNlfSB0aGF0IHdpbGwgYWNjZXB0IHdoZW4gY29tcGxldGUuXHJcbmFzeW5jIGZ1bmN0aW9uIHN0cmVhbVdpdGhQcm9ncmVzcyhcclxuICBsZW5ndGg6IG51bWJlcixcclxuICByZWFkZXI6IFJlYWRhYmxlU3RyZWFtUmVhZGVyLFxyXG4gIHdyaXRlcjogZnMuV3JpdGVTdHJlYW0sXHJcbiAgcHJvZ3Jlc3NDYWxsYmFjaz86IEJ5dGVQcm9ncmVzc0NhbGxiYWNrLFxyXG4pOiBQcm9taXNlPHZvaWQ+IHtcclxuICBsZXQgYnl0ZXNEb25lID0gMDtcclxuXHJcbiAgd2hpbGUgKHRydWUpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XHJcbiAgICBpZiAocmVzdWx0LmRvbmUpIHtcclxuICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2sgIT0gbnVsbCkge1xyXG4gICAgICAgIHByb2dyZXNzQ2FsbGJhY2sobGVuZ3RoLCAxMDApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjaHVuayA9IHJlc3VsdC52YWx1ZTtcclxuICAgIGlmIChjaHVuayA9PSBudWxsKSB7XHJcbiAgICAgIHRocm93IEVycm9yKCdFbXB0eSBjaHVuayByZWNlaXZlZCBkdXJpbmcgZG93bmxvYWQnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHdyaXRlci53cml0ZShCdWZmZXIuZnJvbShjaHVuaykpO1xyXG4gICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjayAhPSBudWxsKSB7XHJcbiAgICAgICAgYnl0ZXNEb25lICs9IGNodW5rLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgY29uc3QgcGVyY2VudDogbnVtYmVyIHwgdW5kZWZpbmVkID0gbGVuZ3RoID09PSAwID8gdW5kZWZpbmVkIDogTWF0aC5mbG9vcihieXRlc0RvbmUgLyBsZW5ndGggKiAxMDApO1xyXG4gICAgICAgIHByb2dyZXNzQ2FsbGJhY2soYnl0ZXNEb25lLCBwZXJjZW50KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gUHVibGljOiBQcm9ncmVzcyBjYWxsYmFjayBmdW5jdGlvbiBzaWduYXR1cmUgaW5kaWNhdGluZyB0aGUgYnl0ZXNEb25lIGFuZFxyXG4vLyBvcHRpb25hbCBwZXJjZW50YWdlIHdoZW4gbGVuZ3RoIGlzIGtub3duLlxyXG5leHBvcnQgdHlwZSBCeXRlUHJvZ3Jlc3NDYWxsYmFjayA9IChieXRlc0RvbmU6IG51bWJlciwgcGVyY2VudD86IG51bWJlcikgPT4gdm9pZDtcclxuIl19