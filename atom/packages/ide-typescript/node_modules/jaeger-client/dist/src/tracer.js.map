{"version":3,"sources":["../../src/tracer.js"],"names":["constants","opentracing","Tracer","serviceName","reporter","sampler","options","_tags","tags","JAEGER_CLIENT_VERSION_TAG_KEY","version","TRACER_HOSTNAME_TAG_KEY","hostname","PROCESS_IP","ipToInt","myIp","_metrics","metrics","_serviceName","_reporter","_sampler","_logger","logger","_baggageSetter","baggageRestrictionManager","_injectors","_extractors","textCodec","urlEncoding","registerInjector","FORMAT_TEXT_MAP","registerExtractor","httpCodec","FORMAT_HTTP_HEADERS","binaryCodec","FORMAT_BINARY","setProcess","convertObjectToTags","spanContext","operationName","startTime","userTags","internalTags","parentContext","rpcServer","references","hadParent","isDebugIDContainerOnly","span","addTags","spansStarted","increment","context","isSampled","spansSampled","tracesStartedSampled","tracesJoinedSampled","spansNotSampled","tracesStartedNotSampled","tracesJoinedNotSampled","spansFinished","report","format","injector","extractor","now","followsFromIsParent","parent","childOf","i","length","ref","type","REFERENCE_CHILD_OF","referencedContext","REFERENCE_FOLLOWS_FROM","spanKindValue","SPAN_KIND","SPAN_KIND_RPC_SERVER","ctx","isValid","randomId","getRandom64","flags","SAMPLED_MASK","DEBUG_MASK","JAEGER_DEBUG_HEADER","debugId","baggage","traceId","spanId","parentId","finalizeSampling","_startInternalSpan","carrier","Error","inject","extract","callback","close","Date"],"mappings":"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","file":"tracer.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport BinaryCodec from './propagators/binary_codec';\nimport ConstSampler from './samplers/const_sampler';\nimport * as constants from './constants';\nimport * as opentracing from 'opentracing';\nimport pjson from '../package.json';\nimport { Tags as opentracing_tags } from 'opentracing';\nimport NoopReporter from './reporters/noop_reporter';\nimport Span from './span';\nimport SpanContext from './span_context';\nimport TextMapCodec from './propagators/text_map_codec';\nimport NullLogger from './logger';\nimport Utils from './util';\nimport Metrics from './metrics/metrics';\nimport NoopMetricFactory from './metrics/noop/metric_factory';\nimport DefaultBaggageRestrictionManager from './baggage/default_baggage_restriction_manager';\nimport os from 'os';\nimport BaggageSetter from './baggage/baggage_setter';\n\nexport default class Tracer {\n  _serviceName: string;\n  _reporter: Reporter;\n  _sampler: Sampler;\n  _logger: NullLogger;\n  _tags: any;\n  _injectors: any;\n  _extractors: any;\n  _metrics: any;\n  _baggageSetter: BaggageSetter;\n\n  /**\n   * @param {String} [serviceName] - name of the current service or application.\n   * @param {Object} [reporter] - reporter used to submit finished spans to Jaeger backend.\n   * @param {Object} [sampler] - sampler used to decide if trace should be sampled when starting a new one.\n   * @param {Object} [options] - the fields to set on the newly created span.\n   * @param {Object} [options.tags] - set of key-value pairs which will be set\n   *        as process-level tags on the Tracer itself.\n   * @param {Object} [options.metrics] - instance of the Metrics class from ./metrics/metrics.js.\n   * @param {Object} [options.logger] - a logger matching NullLogger API from ./logger.js.\n   * @param {Object} [options.baggageRestrictionManager] - a baggageRestrictionManager matching\n   * BaggageRestrictionManager API from ./baggage.js.\n   */\n  constructor(\n    serviceName: string,\n    reporter: Reporter = new NoopReporter(),\n    sampler: Sampler = new ConstSampler(false),\n    options: any = {}\n  ) {\n    this._tags = options.tags || {};\n    this._tags[constants.JAEGER_CLIENT_VERSION_TAG_KEY] = `Node-${pjson.version}`;\n    this._tags[constants.TRACER_HOSTNAME_TAG_KEY] = os.hostname();\n    this._tags[constants.PROCESS_IP] = Utils.ipToInt(Utils.myIp());\n\n    this._metrics = options.metrics || new Metrics(new NoopMetricFactory());\n\n    this._serviceName = serviceName;\n    this._reporter = reporter;\n    this._sampler = sampler;\n    this._logger = options.logger || new NullLogger();\n    this._baggageSetter = new BaggageSetter(\n      options.baggageRestrictionManager || new DefaultBaggageRestrictionManager(),\n      this._metrics\n    );\n    this._injectors = {};\n    this._extractors = {};\n\n    let textCodec = new TextMapCodec({\n      urlEncoding: false,\n      metrics: this._metrics,\n    });\n    this.registerInjector(opentracing.FORMAT_TEXT_MAP, textCodec);\n    this.registerExtractor(opentracing.FORMAT_TEXT_MAP, textCodec);\n\n    let httpCodec = new TextMapCodec({\n      urlEncoding: true,\n      metrics: this._metrics,\n    });\n    this.registerInjector(opentracing.FORMAT_HTTP_HEADERS, httpCodec);\n    this.registerExtractor(opentracing.FORMAT_HTTP_HEADERS, httpCodec);\n\n    let binaryCodec = new BinaryCodec();\n    this.registerInjector(opentracing.FORMAT_BINARY, binaryCodec);\n    this.registerExtractor(opentracing.FORMAT_BINARY, binaryCodec);\n\n    this._reporter.setProcess(this._serviceName, Utils.convertObjectToTags(this._tags));\n  }\n\n  _startInternalSpan(\n    spanContext: SpanContext,\n    operationName: string,\n    startTime: number,\n    userTags: any,\n    internalTags: any,\n    parentContext: ?SpanContext,\n    rpcServer: boolean,\n    references: Array<Reference>\n  ): Span {\n    let hadParent = parentContext && !parentContext.isDebugIDContainerOnly();\n    let span = new Span(this, operationName, spanContext, startTime, references);\n\n    span.addTags(userTags);\n    span.addTags(internalTags);\n\n    // emit metrics\n    this._metrics.spansStarted.increment(1);\n    if (span.context().isSampled()) {\n      this._metrics.spansSampled.increment(1);\n      if (!hadParent) {\n        this._metrics.tracesStartedSampled.increment(1);\n      } else if (rpcServer) {\n        this._metrics.tracesJoinedSampled.increment(1);\n      }\n    } else {\n      this._metrics.spansNotSampled.increment(1);\n      if (!hadParent) {\n        this._metrics.tracesStartedNotSampled.increment(1);\n      } else if (rpcServer) {\n        this._metrics.tracesJoinedNotSampled.increment(1);\n      }\n    }\n\n    return span;\n  }\n\n  _report(span: Span): void {\n    this._metrics.spansFinished.increment(1);\n    this._reporter.report(span);\n  }\n\n  registerInjector(format: string, injector: Injector): void {\n    this._injectors[format] = injector;\n  }\n\n  registerExtractor(format: string, extractor: Extractor): void {\n    this._extractors[format] = extractor;\n  }\n\n  /**\n   * The method for creating a root or child span.\n   *\n   * @param {string} operationName - the name of the operation.\n   * @param {object} [options] - the fields to set on the newly created span.\n   * @param {string} options.operationName - the name to use for the newly\n   *        created span. Required if called with a single argument.\n   * @param {SpanContext} [options.childOf] - a parent SpanContext (or Span,\n   *        for convenience) that the newly-started span will be the child of\n   *        (per REFERENCE_CHILD_OF). If specified, `fields.references` must\n   *        be unspecified.\n   * @param {array} [options.references] - an array of Reference instances,\n   *        each pointing to a causal parent SpanContext. If specified,\n   *        `fields.childOf` must be unspecified.\n   * @param {object} [options.tags] - set of key-value pairs which will be set\n   *        as tags on the newly created Span. Ownership of the object is\n   *        passed to the created span for efficiency reasons (the caller\n   *        should not modify this object after calling startSpan).\n   * @param {number} [options.startTime] - a manually specified start time for\n   *        the created Span object. The time should be specified in\n   *        milliseconds as Unix timestamp. Decimal value are supported\n   *        to represent time values with sub-millisecond accuracy.\n   * @return {Span} - a new Span object.\n   **/\n  startSpan(operationName: string, options: ?startSpanOptions): Span {\n    // Convert options.childOf to options.references as needed.\n    options = options || {};\n    let references = options.references || [];\n\n    let userTags = options.tags || {};\n    let startTime = options.startTime || this.now();\n\n    // This flag is used to ensure that CHILD_OF reference is preferred\n    // as a parent even if it comes after FOLLOWS_FROM reference.\n    let followsFromIsParent = false;\n    let parent: ?SpanContext = options.childOf instanceof Span ? options.childOf.context() : options.childOf;\n    // If there is no childOf in options, then search list of references\n    for (let i = 0; i < references.length; i++) {\n      let ref: Reference = references[i];\n      if (ref.type() === opentracing.REFERENCE_CHILD_OF) {\n        if (!parent || followsFromIsParent) {\n          parent = ref.referencedContext();\n          break;\n        }\n      } else if (ref.type() === opentracing.REFERENCE_FOLLOWS_FROM) {\n        if (!parent) {\n          parent = ref.referencedContext();\n          followsFromIsParent = true;\n        }\n      }\n    }\n\n    let spanKindValue = userTags[opentracing_tags.SPAN_KIND];\n    let rpcServer = spanKindValue === opentracing_tags.SPAN_KIND_RPC_SERVER;\n\n    let ctx: SpanContext = new SpanContext();\n    let internalTags: any = {};\n    if (!parent || !parent.isValid) {\n      let randomId = Utils.getRandom64();\n      let flags = 0;\n      if (this._sampler.isSampled(operationName, internalTags)) {\n        flags |= constants.SAMPLED_MASK;\n      }\n\n      if (parent) {\n        if (parent.isDebugIDContainerOnly()) {\n          flags |= constants.SAMPLED_MASK | constants.DEBUG_MASK;\n          internalTags[constants.JAEGER_DEBUG_HEADER] = parent.debugId;\n        }\n        // baggage that could have been passed via `jaeger-baggage` header\n        ctx.baggage = parent.baggage;\n      }\n\n      ctx.traceId = randomId;\n      ctx.spanId = randomId;\n      ctx.parentId = null;\n      ctx.flags = flags;\n    } else {\n      ctx.traceId = parent.traceId;\n      ctx.spanId = Utils.getRandom64();\n      ctx.parentId = parent.spanId;\n      ctx.flags = parent.flags;\n\n      // reuse parent's baggage as we'll never change it\n      ctx.baggage = parent.baggage;\n\n      parent.finalizeSampling();\n      ctx.finalizeSampling();\n    }\n\n    return this._startInternalSpan(\n      ctx,\n      operationName,\n      startTime,\n      userTags,\n      internalTags,\n      parent,\n      rpcServer,\n      references\n    );\n  }\n\n  /**\n   * Saves the span context into the carrier object for various formats, and encoders.\n   *\n   * @param  {SpanContext} spanContext - the SpanContext to inject into the\n   *         carrier object. As a convenience, a Span instance may be passed\n   *         in instead (in which case its .context() is used for the\n   *         inject()).\n   * @param  {string} format - the format of the carrier.\n   * @param  {any} carrier - see the documentation for the chosen `format`\n   *         for a description of the carrier object.\n   **/\n  inject(spanContext: SpanContext, format: string, carrier: any): void {\n    if (!spanContext) {\n      return;\n    }\n\n    let injector = this._injectors[format];\n    if (!injector) {\n      throw new Error(`Unsupported format: ${format}`);\n    }\n\n    if (spanContext.context) {\n      spanContext = spanContext.context();\n    }\n\n    spanContext.finalizeSampling();\n    injector.inject(spanContext, carrier);\n  }\n\n  /**\n   * Responsible for extracting a span context from various serialized formats.\n   *\n   * @param  {string} format - the format of the carrier.\n   * @param  {any} carrier - the type of the carrier object is determined by\n   *         the format.\n   * @return {SpanContext}\n   *         The extracted SpanContext, or null if no such SpanContext could\n   *         be found in `carrier`\n   */\n  extract(format: string, carrier: any): SpanContext {\n    let extractor = this._extractors[format];\n    if (!extractor) {\n      throw new Error(`Unsupported format: ${format}`);\n    }\n\n    let spanContext = extractor.extract(carrier);\n\n    if (spanContext) {\n      spanContext.finalizeSampling();\n    }\n    return spanContext;\n  }\n\n  /**\n   * Closes the tracer, flushes spans, and executes any callbacks if necessary.\n   *\n   * @param {Function} [callback] - a callback that runs after the tracer has been closed.\n   **/\n  close(callback: Function): void {\n    let reporter = this._reporter;\n    this._reporter = new NoopReporter();\n    reporter.close(() => {\n      this._sampler.close(callback);\n    });\n  }\n\n  /**\n   * Returns the current timestamp in milliseconds since the Unix epoch.\n   * Fractional values are allowed so that timestamps with sub-millisecond\n   * accuracy can be represented.\n   */\n  now(): number {\n    // TODO investigate process.hrtime; verify it is available in all Node versions.\n    // http://stackoverflow.com/questions/11725691/how-to-get-a-microtime-in-node-js\n    return Date.now();\n  }\n}\n"]}