{"version":3,"sources":["../../src/span_context.js"],"names":["constants","SpanContext","traceId","spanId","parentId","traceIdStr","spanIdStr","parentIdStr","flags","baggage","debugId","samplingFinalized","_traceId","_spanId","_parentId","_traceIdStr","_spanIdStr","_parentIdStr","_flags","_baggage","_debugId","_samplingFinalized","isValid","SAMPLED_MASK","DEBUG_MASK","key","value","newBaggage","clone","toString","join","encodeInt64","removeLeadingZeros","serializedString","headers","split","length","approxTraceId","parseInt","NaNDetected","isNaN","withStringIds"],"mappings":";;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;IAAYA,S;;AACZ;;;;;;;;;;IAEqBC,W;AA4BnB,uBACEC,OADF,EAEEC,MAFF,EAGEC,QAHF,EAIEC,UAJF,EAKEC,SALF,EAMEC,WANF,EAWE;AAAA,QAJAC,KAIA,uEAJgB,CAIhB;AAAA,QAHAC,OAGA,uEAHe,EAGf;AAAA,QAFAC,OAEA,uEAFmB,EAEnB;AAAA,QADAC,iBACA,uEAD6B,KAC7B;;AAAA;;AACA,SAAKC,QAAL,GAAgBV,OAAhB;AACA,SAAKW,OAAL,GAAeV,MAAf;AACA,SAAKW,SAAL,GAAiBV,QAAjB;AACA,SAAKW,WAAL,GAAmBV,UAAnB;AACA,SAAKW,UAAL,GAAkBV,SAAlB;AACA,SAAKW,YAAL,GAAoBV,WAApB;AACA,SAAKW,MAAL,GAAcV,KAAd;AACA,SAAKW,QAAL,GAAgBV,OAAhB;AACA,SAAKW,QAAL,GAAgBV,OAAhB;AACA,SAAKW,kBAAL,GAA0BV,iBAA1B;AACD;AAxCD;;;;;;;;;;;;;;;;;;;;uCAmIyB;AACvB,WAAKU,kBAAL,GAA0B,IAA1B;AACD;;;6CAEiC;AAChC,aAAO,CAAC,KAAKC,OAAN,IAAiB,KAAKF,QAAL,KAAkB,EAA1C;AACD;;AAED;;;;;;gCAGqB;AACnB,aAAO,CAAC,KAAKZ,KAAL,GAAaR,UAAUuB,YAAxB,MAA0CvB,UAAUuB,YAA3D;AACD;;AAED;;;;;;8BAGmB;AACjB,aAAO,CAAC,KAAKf,KAAL,GAAaR,UAAUwB,UAAxB,MAAwCxB,UAAUwB,UAAzD;AACD;;;oCAEeC,G,EAAaC,K,EAA4B;AACvD,UAAIC,aAAa,eAAMC,KAAN,CAAY,KAAKT,QAAjB,CAAjB;AACAQ,iBAAWF,GAAX,IAAkBC,KAAlB;AACA,aAAO,IAAIzB,WAAJ,CACL,KAAKW,QADA,EAEL,KAAKC,OAFA,EAGL,KAAKC,SAHA,EAIL,KAAKC,WAJA,EAKL,KAAKC,UALA,EAML,KAAKC,YANA,EAOL,KAAKC,MAPA,EAQLS,UARK,EASL,KAAKP,QATA,EAUL,KAAKC,kBAVA,CAAP;AAYD;;AAED;;;;;;+BAGmB;AACjB,aAAO,CAAC,KAAKhB,UAAN,EAAkB,KAAKC,SAAvB,EAAkC,KAAKC,WAAL,IAAoB,GAAtD,EAA2D,KAAKW,MAAL,CAAYW,QAAZ,CAAqB,EAArB,CAA3D,EAAqFC,IAArF,CAA0F,GAA1F,CAAP;AACD;;AAED;;;;;;;wBAvImB;AACjB,UAAI,KAAKlB,QAAL,IAAiB,IAAjB,IAAyB,KAAKG,WAAL,IAAoB,IAAjD,EAAuD;AACrD,aAAKH,QAAL,GAAgB,eAAMmB,WAAN,CAAkB,KAAKhB,WAAvB,CAAhB;AACD;AACD,aAAO,KAAKH,QAAZ;AACD,K;sBAqDWV,O,EAAuB;AACjC,WAAKU,QAAL,GAAgBV,OAAhB;AACA,WAAKa,WAAL,GAAmB,IAAnB;AACD;;;wBAtDiB;AAChB,UAAI,KAAKF,OAAL,IAAgB,IAAhB,IAAwB,KAAKG,UAAL,IAAmB,IAA/C,EAAqD;AACnD,aAAKH,OAAL,GAAe,eAAMkB,WAAN,CAAkB,KAAKf,UAAvB,CAAf;AACD;AACD,aAAO,KAAKH,OAAZ;AACD,K;sBAmDUV,M,EAAsB;AAC/B,WAAKU,OAAL,GAAeV,MAAf;AACA,WAAKa,UAAL,GAAkB,IAAlB;AACD;;;wBApDmB;AAClB,UAAI,KAAKF,SAAL,IAAkB,IAAlB,IAA0B,KAAKG,YAAL,IAAqB,IAAnD,EAAyD;AACvD,aAAKH,SAAL,GAAiB,eAAMiB,WAAN,CAAkB,KAAKd,YAAvB,CAAjB;AACD;AACD,aAAO,KAAKH,SAAZ;AACD,K;sBAiDYV,Q,EAAwB;AACnC,WAAKU,SAAL,GAAiBV,QAAjB;AACA,WAAKa,YAAL,GAAoB,IAApB;AACD;;;wBAlDyB;AACxB,UAAI,KAAKF,WAAL,IAAoB,IAApB,IAA4B,KAAKH,QAAL,IAAiB,IAAjD,EAAuD;AACrD,aAAKG,WAAL,GAAmB,eAAMiB,kBAAN,CAAyB,KAAKpB,QAAL,CAAciB,QAAd,CAAuB,KAAvB,CAAzB,CAAnB;AACD;AACD,aAAO,KAAKd,WAAZ;AACD;;;wBAEwB;AACvB,UAAI,KAAKC,UAAL,IAAmB,IAAnB,IAA2B,KAAKH,OAAL,IAAgB,IAA/C,EAAqD;AACnD,aAAKG,UAAL,GAAkB,eAAMgB,kBAAN,CAAyB,KAAKnB,OAAL,CAAagB,QAAb,CAAsB,KAAtB,CAAzB,CAAlB;AACD;AACD,aAAO,KAAKb,UAAZ;AACD;;;wBAE0B;AACzB,UAAI,KAAKC,YAAL,IAAqB,IAArB,IAA6B,KAAKH,SAAL,IAAkB,IAAnD,EAAyD;AACvD,aAAKG,YAAL,GAAoB,eAAMe,kBAAN,CAAyB,KAAKlB,SAAL,CAAee,QAAf,CAAwB,KAAxB,CAAzB,CAApB;AACD;AACD,aAAO,KAAKZ,YAAZ;AACD;;;wBAEmB;AAClB,aAAO,KAAKC,MAAZ;AACD,K;sBA6BSV,K,EAAqB;AAC7B,WAAKU,MAAL,GAAcV,KAAd;AACD;;;wBA7BkB;AACjB,aAAO,KAAKW,QAAZ;AACD,K;sBA6BWV,O,EAAoB;AAC9B,WAAKU,QAAL,GAAgBV,OAAhB;AACD;;;wBA7BsB;AACrB,aAAO,KAAKW,QAAZ;AACD,K;sBA6BWV,O,EAAwB;AAClC,WAAKU,QAAL,GAAgBV,OAAhB;AACD;;;wBA7BgC;AAC/B,aAAO,KAAKW,kBAAZ;AACD;;;wBA6BsB;AACrB,aAAO,CAAC,EAAE,CAAC,KAAKT,QAAL,IAAiB,KAAKG,WAAvB,MAAwC,KAAKF,OAAL,IAAgB,KAAKG,UAA7D,CAAF,CAAR;AACD;;;+BAoDiBiB,gB,EAA+B;AAC/C,UAAIC,UAAeD,iBAAiBE,KAAjB,CAAuB,GAAvB,CAAnB;AACA,UAAID,QAAQE,MAAR,KAAmB,CAAvB,EAA0B;AACxB,eAAO,IAAP;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,UAAIC,gBAAgBC,SAASJ,QAAQ,CAAR,CAAT,EAAqB,EAArB,CAApB;AACA,UAAIK,cACFC,MAAMH,aAAN,EAAqB,EAArB,KACAA,kBAAkB,CADlB,IAEAG,MAAMF,SAASJ,QAAQ,CAAR,CAAT,EAAqB,EAArB,CAAN,CAFA,IAGAM,MAAMF,SAASJ,QAAQ,CAAR,CAAT,EAAqB,EAArB,CAAN,CAHA,IAIAM,MAAMF,SAASJ,QAAQ,CAAR,CAAT,EAAqB,EAArB,CAAN,CALF;;AAOA,UAAIK,WAAJ,EAAiB;AACf,eAAO,IAAP;AACD;;AAED,UAAInC,WAAW,IAAf;AACA,UAAI8B,QAAQ,CAAR,MAAe,GAAnB,EAAwB;AACtB9B,mBAAW8B,QAAQ,CAAR,CAAX;AACD;;AAED,aAAOjC,YAAYwC,aAAZ,CAA0BP,QAAQ,CAAR,CAA1B,EAAsCA,QAAQ,CAAR,CAAtC,EAAkD9B,QAAlD,EAA4DkC,SAASJ,QAAQ,CAAR,CAAT,EAAqB,EAArB,CAA5D,CAAP;AACD;;;kCAGChC,O,EACAC,M,EACAC,Q,EACAI,K,EAGa;AAAA,UAFbC,OAEa,uEAFE,EAEF;AAAA,UADbC,OACa,uEADM,EACN;;AACb,aAAO,IAAIT,WAAJ,CACLC,OADK,EAELC,MAFK,EAGLC,QAHK,EAIL,IAJK,EAIC;AACN,UALK,EAKC;AACN,UANK,EAMC;AACNI,WAPK,EAQLC,OARK,EASLC,OATK,CAAP;AAWD;;;kCAGCL,U,EACAC,S,EACAC,W,EACAC,K,EAGa;AAAA,UAFbC,OAEa,uEAFE,EAEF;AAAA,UADbC,OACa,uEADM,EACN;;AACb,aAAO,IAAIT,WAAJ,CACL,IADK,EACC;AACN,UAFK,EAEC;AACN,UAHK,EAGC;AACNI,gBAJK,EAKLC,SALK,EAMLC,WANK,EAOLC,KAPK,EAQLC,OARK,EASLC,OATK,CAAP;AAWD;;;;;;kBAvQkBT,W","file":"span_context.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport * as constants from './constants.js';\nimport Utils from './util.js';\n\nexport default class SpanContext {\n  _traceId: any;\n  _spanId: any;\n  _parentId: any;\n  _traceIdStr: ?string;\n  _spanIdStr: ?string;\n  _parentIdStr: ?string;\n  _flags: number;\n  _baggage: any;\n  _debugId: ?string;\n  /**\n   * This field exists to help distinguish between when a span can have a properly\n   * correlated operation name -> sampling rate mapping, and when it cannot.\n   * Adaptive sampling uses the operation name of a span to correlate it with\n   * a sampling rate.  If an operation name is set on a span after the span's creation\n   * then adaptive sampling cannot associate the operation name with the proper sampling rate.\n   * In order to correct this we allow a span to be written to, so that we can re-sample\n   * it in the case that an operation name is set after span creation. Situations\n   * where a span context's sampling decision is finalized include:\n   * - it has inherited the sampling decision from its parent\n   * - its debug flag is set via the sampling.priority tag\n   * - it is finish()-ed\n   * - setOperationName is called\n   * - it is used as a parent for another span\n   * - its context is serialized using injectors\n   * */\n  _samplingFinalized: boolean;\n\n  constructor(\n    traceId: any,\n    spanId: any,\n    parentId: any,\n    traceIdStr: ?string,\n    spanIdStr: ?string,\n    parentIdStr: ?string,\n    flags: number = 0,\n    baggage: any = {},\n    debugId: ?string = '',\n    samplingFinalized: boolean = false\n  ) {\n    this._traceId = traceId;\n    this._spanId = spanId;\n    this._parentId = parentId;\n    this._traceIdStr = traceIdStr;\n    this._spanIdStr = spanIdStr;\n    this._parentIdStr = parentIdStr;\n    this._flags = flags;\n    this._baggage = baggage;\n    this._debugId = debugId;\n    this._samplingFinalized = samplingFinalized;\n  }\n\n  get traceId(): any {\n    if (this._traceId == null && this._traceIdStr != null) {\n      this._traceId = Utils.encodeInt64(this._traceIdStr);\n    }\n    return this._traceId;\n  }\n\n  get spanId(): any {\n    if (this._spanId == null && this._spanIdStr != null) {\n      this._spanId = Utils.encodeInt64(this._spanIdStr);\n    }\n    return this._spanId;\n  }\n\n  get parentId(): any {\n    if (this._parentId == null && this._parentIdStr != null) {\n      this._parentId = Utils.encodeInt64(this._parentIdStr);\n    }\n    return this._parentId;\n  }\n\n  get traceIdStr(): ?string {\n    if (this._traceIdStr == null && this._traceId != null) {\n      this._traceIdStr = Utils.removeLeadingZeros(this._traceId.toString('hex'));\n    }\n    return this._traceIdStr;\n  }\n\n  get spanIdStr(): ?string {\n    if (this._spanIdStr == null && this._spanId != null) {\n      this._spanIdStr = Utils.removeLeadingZeros(this._spanId.toString('hex'));\n    }\n    return this._spanIdStr;\n  }\n\n  get parentIdStr(): ?string {\n    if (this._parentIdStr == null && this._parentId != null) {\n      this._parentIdStr = Utils.removeLeadingZeros(this._parentId.toString('hex'));\n    }\n    return this._parentIdStr;\n  }\n\n  get flags(): number {\n    return this._flags;\n  }\n\n  get baggage(): any {\n    return this._baggage;\n  }\n\n  get debugId(): ?string {\n    return this._debugId;\n  }\n\n  get samplingFinalized(): boolean {\n    return this._samplingFinalized;\n  }\n\n  set traceId(traceId: Buffer): void {\n    this._traceId = traceId;\n    this._traceIdStr = null;\n  }\n\n  set spanId(spanId: Buffer): void {\n    this._spanId = spanId;\n    this._spanIdStr = null;\n  }\n\n  set parentId(parentId: Buffer): void {\n    this._parentId = parentId;\n    this._parentIdStr = null;\n  }\n\n  set flags(flags: number): void {\n    this._flags = flags;\n  }\n\n  set baggage(baggage: any): void {\n    this._baggage = baggage;\n  }\n\n  set debugId(debugId: ?string): void {\n    this._debugId = debugId;\n  }\n\n  get isValid(): boolean {\n    return !!((this._traceId || this._traceIdStr) && (this._spanId || this._spanIdStr));\n  }\n\n  finalizeSampling(): void {\n    this._samplingFinalized = true;\n  }\n\n  isDebugIDContainerOnly(): boolean {\n    return !this.isValid && this._debugId !== '';\n  }\n\n  /**\n   * @return {boolean} - returns whether or not this span context was sampled.\n   **/\n  isSampled(): boolean {\n    return (this.flags & constants.SAMPLED_MASK) === constants.SAMPLED_MASK;\n  }\n\n  /**\n   * @return {boolean} - returns whether or not this span context has a debug flag set.\n   **/\n  isDebug(): boolean {\n    return (this.flags & constants.DEBUG_MASK) === constants.DEBUG_MASK;\n  }\n\n  withBaggageItem(key: string, value: string): SpanContext {\n    let newBaggage = Utils.clone(this._baggage);\n    newBaggage[key] = value;\n    return new SpanContext(\n      this._traceId,\n      this._spanId,\n      this._parentId,\n      this._traceIdStr,\n      this._spanIdStr,\n      this._parentIdStr,\n      this._flags,\n      newBaggage,\n      this._debugId,\n      this._samplingFinalized\n    );\n  }\n\n  /**\n   * @return {string} - returns a string version of this span context.\n   **/\n  toString(): string {\n    return [this.traceIdStr, this.spanIdStr, this.parentIdStr || '0', this._flags.toString(16)].join(':');\n  }\n\n  /**\n   * @param {string} serializedString - a serialized span context.\n   * @return {SpanContext} - returns a span context represented by the serializedString.\n   **/\n  static fromString(serializedString: string): any {\n    let headers: any = serializedString.split(':');\n    if (headers.length !== 4) {\n      return null;\n    }\n\n    // Note: Number type in JS cannot represent the full range of 64bit unsigned ints,\n    // so using parseInt() on strings representing 64bit hex numbers only returns\n    // an approximation of the actual value. Fortunately, we do not depend on the\n    // returned value, we are only using it to validate that the string is\n    // a valid hex number (which is faster than doing it manually).  We cannot use\n    // Int64(numberValue).toBuffer() because it throws exceptions on bad strings.\n    let approxTraceId = parseInt(headers[0], 16);\n    let NaNDetected =\n      isNaN(approxTraceId, 16) ||\n      approxTraceId === 0 ||\n      isNaN(parseInt(headers[1], 16)) ||\n      isNaN(parseInt(headers[2], 16)) ||\n      isNaN(parseInt(headers[3], 16));\n\n    if (NaNDetected) {\n      return null;\n    }\n\n    let parentId = null;\n    if (headers[2] !== '0') {\n      parentId = headers[2];\n    }\n\n    return SpanContext.withStringIds(headers[0], headers[1], parentId, parseInt(headers[3], 16));\n  }\n\n  static withBinaryIds(\n    traceId: any,\n    spanId: any,\n    parentId: any,\n    flags: number,\n    baggage: any = {},\n    debugId: ?string = ''\n  ): SpanContext {\n    return new SpanContext(\n      traceId,\n      spanId,\n      parentId,\n      null, // traceIdStr: string,\n      null, // spanIdStr: string,\n      null, // parentIdStr: string,\n      flags,\n      baggage,\n      debugId\n    );\n  }\n\n  static withStringIds(\n    traceIdStr: any,\n    spanIdStr: any,\n    parentIdStr: any,\n    flags: number,\n    baggage: any = {},\n    debugId: ?string = ''\n  ): SpanContext {\n    return new SpanContext(\n      null, // traceId,\n      null, // spanId,\n      null, // parentId,\n      traceIdStr,\n      spanIdStr,\n      parentIdStr,\n      flags,\n      baggage,\n      debugId\n    );\n  }\n}\n"]}